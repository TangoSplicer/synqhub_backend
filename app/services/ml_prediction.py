"""Machine learning prediction service for Phase 6 intelligence."""

from datetime import datetime
from typing import Optional, List, Dict, Any
from uuid import UUID, uuid4

from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.ml_prediction import (\n    MLModel,\n    MLPrediction,\n    CircuitOptimization,\n    ResourceEstimate,\n    PatternAnalysis,\n)\n\n\nclass MLPredictionService:\n    \"\"\"Service for managing ML predictions and models.\"\"\"\n    \n    @staticmethod\n    async def create_model(\n        db: AsyncSession,\n        name: str,\n        version: str,\n        model_type: str,\n        framework: str,\n        input_schema: Dict[str, Any],\n        output_schema: Dict[str, Any],\n        description: Optional[str] = None,\n    ) -> MLModel:\n        \"\"\"Create a new ML model.\"\"\"\n        model = MLModel(\n            id=uuid4(),\n            name=name,\n            version=version,\n            model_type=model_type,\n            framework=framework,\n            input_schema=input_schema,\n            output_schema=output_schema,\n            description=description,\n            is_active=False,\n            is_production=False,\n        )\n        db.add(model)\n        await db.commit()\n        return model\n    \n    @staticmethod\n    async def get_model(db: AsyncSession, model_id: UUID) -> Optional[MLModel]:\n        \"\"\"Get an ML model by ID.\"\"\"\n        result = await db.execute(\n            select(MLModel).where(MLModel.id == model_id)\n        )\n        return result.scalar_one_or_none()\n    \n    @staticmethod\n    async def get_model_by_name(db: AsyncSession, name: str) -> Optional[MLModel]:\n        \"\"\"Get an ML model by name.\"\"\"\n        result = await db.execute(\n            select(MLModel).where(MLModel.name == name)\n        )\n        return result.scalar_one_or_none()\n    \n    @staticmethod\n    async def list_models(\n        db: AsyncSession,\n        model_type: Optional[str] = None,\n        is_active: Optional[bool] = None,\n        is_production: Optional[bool] = None,\n        skip: int = 0,\n        limit: int = 20,\n    ) -> List[MLModel]:\n        \"\"\"List ML models with optional filtering.\"\"\"\n        query = select(MLModel)\n        \n        filters = []\n        if model_type:\n            filters.append(MLModel.model_type == model_type)\n        if is_active is not None:\n            filters.append(MLModel.is_active == is_active)\n        if is_production is not None:\n            filters.append(MLModel.is_production == is_production)\n        \n        if filters:\n            query = query.where(and_(*filters))\n        \n        query = query.offset(skip).limit(limit)\n        result = await db.execute(query)\n        return result.scalars().all()\n    \n    @staticmethod\n    async def activate_model(db: AsyncSession, model_id: UUID) -> Optional[MLModel]:\n        \"\"\"Activate an ML model.\"\"\"\n        model = await MLPredictionService.get_model(db, model_id)\n        if model:\n            model.is_active = True\n            await db.commit()\n        return model\n    \n    @staticmethod\n    async def promote_to_production(\n        db: AsyncSession,\n        model_id: UUID,\n    ) -> Optional[MLModel]:\n        \"\"\"Promote an ML model to production.\"\"\"\n        model = await MLPredictionService.get_model(db, model_id)\n        if model:\n            model.is_production = True\n            model.is_active = True\n            await db.commit()\n        return model\n    \n    @staticmethod\n    async def record_prediction(\n        db: AsyncSession,\n        user_id: UUID,\n        model_id: UUID,\n        prediction_type: str,\n        input_data: Dict[str, Any],\n        predicted_output: Dict[str, Any],\n        confidence: float,\n        circuit_id: Optional[UUID] = None,\n        job_id: Optional[UUID] = None,\n        execution_time_ms: Optional[float] = None,\n    ) -> MLPrediction:\n        \"\"\"Record a machine learning prediction.\"\"\"\n        prediction = MLPrediction(\n            id=uuid4(),\n            user_id=user_id,\n            model_id=model_id,\n            circuit_id=circuit_id,\n            job_id=job_id,\n            prediction_type=prediction_type,\n            input_data=input_data,\n            predicted_output=predicted_output,\n            confidence=confidence,\n            execution_time_ms=execution_time_ms,\n        )\n        db.add(prediction)\n        await db.commit()\n        return prediction\n    \n    @staticmethod\n    async def get_prediction(db: AsyncSession, prediction_id: UUID) -> Optional[MLPrediction]:\n        \"\"\"Get a prediction by ID.\"\"\"\n        result = await db.execute(\n            select(MLPrediction).where(MLPrediction.id == prediction_id)\n        )\n        return result.scalar_one_or_none()\n    \n    @staticmethod\n    async def get_circuit_predictions(\n        db: AsyncSession,\n        circuit_id: UUID,\n        skip: int = 0,\n        limit: int = 20,\n    ) -> List[MLPrediction]:\n        \"\"\"Get predictions for a circuit.\"\"\"\n        result = await db.execute(\n            select(MLPrediction)\n            .where(MLPrediction.circuit_id == circuit_id)\n            .order_by(MLPrediction.created_at.desc())\n            .offset(skip)\n            .limit(limit)\n        )\n        return result.scalars().all()\n    \n    @staticmethod\n    async def add_prediction_feedback(\n        db: AsyncSession,\n        prediction_id: UUID,\n        rating: int,\n        feedback: Optional[str] = None,\n        was_helpful: Optional[bool] = None,\n    ) -> Optional[MLPrediction]:\n        \"\"\"Add user feedback to a prediction.\"\"\"\n        prediction = await MLPredictionService.get_prediction(db, prediction_id)\n        if prediction:\n            prediction.user_rating = rating\n            prediction.user_feedback = feedback\n            prediction.was_helpful = was_helpful\n            await db.commit()\n        return prediction\n    \n    @staticmethod\n    async def record_optimization(\n        db: AsyncSession,\n        prediction_id: UUID,\n        circuit_id: UUID,\n        original_gate_count: int,\n        original_depth: int,\n        original_two_qubit_gates: int,\n        optimized_gate_count: int,\n        optimized_depth: int,\n        optimized_two_qubit_gates: int,\n        optimization_technique: str,\n        optimization_steps: List[Dict[str, Any]],\n        optimized_circuit: Dict[str, Any],\n    ) -> CircuitOptimization:\n        \"\"\"Record a circuit optimization suggestion.\"\"\"\n        # Calculate improvement percentage\n        original_total = original_gate_count + original_depth\n        optimized_total = optimized_gate_count + optimized_depth\n        improvement = ((original_total - optimized_total) / original_total * 100) if original_total > 0 else 0\n        \n        optimization = CircuitOptimization(\n            id=uuid4(),\n            prediction_id=prediction_id,\n            circuit_id=circuit_id,\n            original_gate_count=original_gate_count,\n            original_depth=original_depth,\n            original_two_qubit_gates=original_two_qubit_gates,\n            optimized_gate_count=optimized_gate_count,\n            optimized_depth=optimized_depth,\n            optimized_two_qubit_gates=optimized_two_qubit_gates,\n            optimization_technique=optimization_technique,\n            optimization_steps=optimization_steps,\n            optimized_circuit=optimized_circuit,\n            estimated_improvement=improvement,\n            applied=False,\n        )\n        db.add(optimization)\n        await db.commit()\n        return optimization\n    \n    @staticmethod\n    async def apply_optimization(\n        db: AsyncSession,\n        optimization_id: UUID,\n    ) -> Optional[CircuitOptimization]:\n        \"\"\"Mark an optimization as applied.\"\"\"\n        result = await db.execute(\n            select(CircuitOptimization).where(CircuitOptimization.id == optimization_id)\n        )\n        optimization = result.scalar_one_or_none()\n        if optimization:\n            optimization.applied = True\n            optimization.applied_at = datetime.utcnow()\n            await db.commit()\n        return optimization\n    \n    @staticmethod\n    async def record_resource_estimate(\n        db: AsyncSession,\n        prediction_id: UUID,\n        circuit_id: UUID,\n        qubits_required: int,\n        classical_bits_required: int,\n        single_qubit_gates: int,\n        two_qubit_gates: int,\n        measurement_gates: int,\n        circuit_depth: int,\n        circuit_width: int,\n        estimated_execution_time_ms: float,\n        compatible_backends: List[str],\n        confidence: float,\n        recommended_backend: Optional[str] = None,\n    ) -> ResourceEstimate:\n        \"\"\"Record a resource requirement estimate.\"\"\"\n        estimate = ResourceEstimate(\n            id=uuid4(),\n            prediction_id=prediction_id,\n            circuit_id=circuit_id,\n            qubits_required=qubits_required,\n            classical_bits_required=classical_bits_required,\n            single_qubit_gates=single_qubit_gates,\n            two_qubit_gates=two_qubit_gates,\n            measurement_gates=measurement_gates,\n            circuit_depth=circuit_depth,\n            circuit_width=circuit_width,\n            estimated_execution_time_ms=estimated_execution_time_ms,\n            compatible_backends=compatible_backends,\n            recommended_backend=recommended_backend,\n            confidence=confidence,\n        )\n        db.add(estimate)\n        await db.commit()\n        return estimate\n    \n    @staticmethod\n    async def record_pattern_analysis(\n        db: AsyncSession,\n        prediction_id: UUID,\n        circuit_id: UUID,\n        detected_patterns: List[str],\n        pattern_confidence: float,\n        recommended_optimizations: List[str],\n        algorithm_type: Optional[str] = None,\n        algorithm_confidence: Optional[float] = None,\n        alternative_implementations: Optional[List[Dict[str, Any]]] = None,\n        similar_circuits: Optional[List[UUID]] = None,\n        similarity_scores: Optional[List[float]] = None,\n    ) -> PatternAnalysis:\n        \"\"\"Record a pattern analysis result.\"\"\"\n        analysis = PatternAnalysis(\n            id=uuid4(),\n            prediction_id=prediction_id,\n            circuit_id=circuit_id,\n            detected_patterns=detected_patterns,\n            pattern_confidence=pattern_confidence,\n            algorithm_type=algorithm_type,\n            algorithm_confidence=algorithm_confidence,\n            recommended_optimizations=recommended_optimizations,\n            alternative_implementations=alternative_implementations,\n            similar_circuits=similar_circuits,\n            similarity_scores=similarity_scores,\n        )\n        db.add(analysis)\n        await db.commit()\n        return analysis\n    \n    @staticmethod\n    async def get_model_performance(\n        db: AsyncSession,\n        model_id: UUID,\n    ) -> Dict[str, Any]:\n        \"\"\"Get performance metrics for a model.\"\"\"\n        model = await MLPredictionService.get_model(db, model_id)\n        if not model:\n            return {}\n        \n        # Count predictions\n        predictions_result = await db.execute(\n            select(MLPrediction).where(MLPrediction.model_id == model_id)\n        )\n        predictions = predictions_result.scalars().all()\n        \n        # Calculate average confidence\n        avg_confidence = (\n            sum(p.confidence for p in predictions) / len(predictions)\n            if predictions\n            else 0\n        )\n        \n        # Count helpful predictions\n        helpful = sum(1 for p in predictions if p.was_helpful is True)\n        unhelpful = sum(1 for p in predictions if p.was_helpful is False)\n        \n        return {\n            \"model_id\": model_id,\n            \"name\": model.name,\n            \"version\": model.version,\n            \"type\": model.model_type,\n            \"total_predictions\": len(predictions),\n            \"average_confidence\": avg_confidence,\n            \"helpful_count\": helpful,\n            \"unhelpful_count\": unhelpful,\n            \"accuracy\": model.accuracy,\n            \"precision\": model.precision,\n            \"recall\": model.recall,\n            \"f1_score\": model.f1_score,\n            \"is_active\": model.is_active,\n            \"is_production\": model.is_production,\n        }\n
