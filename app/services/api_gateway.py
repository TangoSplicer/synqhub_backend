"""API Gateway service for managing routes, rate limiting, and analytics."""

from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any
from uuid import UUID, uuid4
import hashlib

from sqlalchemy import select, and_, func
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.api_gateway import (\n    APIRoute,\n    APIRequest,\n    APIKey,\n    RateLimitQuota,\n    APIAnalytics,\n    GraphQLSchema,\n)\n\n\nclass APIGatewayService:\n    \"\"\"Service for managing API gateway operations.\"\"\"\n    \n    @staticmethod\n    async def create_route(\n        db: AsyncSession,\n        name: str,\n        path: str,\n        method: str,\n        target_service: str,\n        target_path: str,\n        description: Optional[str] = None,\n        request_transformation: Optional[Dict[str, Any]] = None,\n        response_transformation: Optional[Dict[str, Any]] = None,\n        rate_limit_requests: Optional[int] = None,\n        rate_limit_window_seconds: Optional[int] = None,\n        requires_auth: bool = True,\n        required_scopes: Optional[List[str]] = None,\n    ) -> APIRoute:\n        \"\"\"Create a new API route.\"\"\"\n        route = APIRoute(\n            id=uuid4(),\n            name=name,\n            path=path,\n            method=method,\n            target_service=target_service,\n            target_path=target_path,\n            description=description,\n            request_transformation=request_transformation,\n            response_transformation=response_transformation,\n            rate_limit_requests=rate_limit_requests,\n            rate_limit_window_seconds=rate_limit_window_seconds,\n            requires_auth=requires_auth,\n            required_scopes=required_scopes,\n            is_active=True,\n        )\n        db.add(route)\n        await db.commit()\n        return route\n    \n    @staticmethod\n    async def get_route(db: AsyncSession, route_id: UUID) -> Optional[APIRoute]:\n        \"\"\"Get an API route by ID.\"\"\"\n        result = await db.execute(\n            select(APIRoute).where(APIRoute.id == route_id)\n        )\n        return result.scalar_one_or_none()\n    \n    @staticmethod\n    async def get_route_by_path(\n        db: AsyncSession,\n        path: str,\n        method: str,\n    ) -> Optional[APIRoute]:\n        \"\"\"Get an API route by path and method.\"\"\"\n        result = await db.execute(\n            select(APIRoute).where(\n                and_(\n                    APIRoute.path == path,\n                    APIRoute.method == method,\n                    APIRoute.is_active.is_(True),\n                )\n            )\n        )\n        return result.scalar_one_or_none()\n    \n    @staticmethod\n    async def list_routes(\n        db: AsyncSession,\n        skip: int = 0,\n        limit: int = 20,\n        is_active: Optional[bool] = None,\n    ) -> List[APIRoute]:\n        \"\"\"List API routes.\"\"\"\n        query = select(APIRoute)\n        if is_active is not None:\n            query = query.where(APIRoute.is_active == is_active)\n        query = query.offset(skip).limit(limit)\n        result = await db.execute(query)\n        return result.scalars().all()\n    \n    @staticmethod\n    async def update_route(\n        db: AsyncSession,\n        route_id: UUID,\n        **kwargs,\n    ) -> Optional[APIRoute]:\n        \"\"\"Update an API route.\"\"\"\n        route = await APIGatewayService.get_route(db, route_id)\n        if route:\n            for key, value in kwargs.items():\n                if hasattr(route, key):\n                    setattr(route, key, value)\n            route.updated_at = datetime.utcnow()\n            await db.commit()\n        return route\n    \n    @staticmethod\n    async def record_request(\n        db: AsyncSession,\n        method: str,\n        path: str,\n        status_code: int,\n        response_time_ms: float,\n        user_id: Optional[UUID] = None,\n        route_id: Optional[UUID] = None,\n        query_params: Optional[Dict[str, Any]] = None,\n        request_size_bytes: Optional[int] = None,\n        response_size_bytes: Optional[int] = None,\n        error_message: Optional[str] = None,\n        error_type: Optional[str] = None,\n        user_agent: Optional[str] = None,\n        client_ip: Optional[str] = None,\n    ) -> APIRequest:\n        \"\"\"Record an API request.\"\"\"\n        request = APIRequest(\n            id=uuid4(),\n            method=method,\n            path=path,\n            status_code=status_code,\n            response_time_ms=response_time_ms,\n            user_id=user_id,\n            route_id=route_id,\n            query_params=query_params,\n            request_size_bytes=request_size_bytes,\n            response_size_bytes=response_size_bytes,\n            error_message=error_message,\n            error_type=error_type,\n            user_agent=user_agent,\n            client_ip=client_ip,\n        )\n        db.add(request)\n        await db.commit()\n        return request\n    \n    @staticmethod\n    async def get_requests(\n        db: AsyncSession,\n        skip: int = 0,\n        limit: int = 100,\n        user_id: Optional[UUID] = None,\n        status_code: Optional[int] = None,\n    ) -> List[APIRequest]:\n        \"\"\"Get API requests with optional filtering.\"\"\"\n        query = select(APIRequest)\n        filters = []\n        if user_id:\n            filters.append(APIRequest.user_id == user_id)\n        if status_code:\n            filters.append(APIRequest.status_code == status_code)\n        if filters:\n            query = query.where(and_(*filters))\n        query = query.order_by(APIRequest.timestamp.desc()).offset(skip).limit(limit)\n        result = await db.execute(query)\n        return result.scalars().all()\n    \n    @staticmethod\n    async def create_api_key(\n        db: AsyncSession,\n        user_id: UUID,\n        name: str,\n        scopes: List[str],\n        rate_limit_requests: Optional[int] = None,\n        rate_limit_window_seconds: Optional[int] = None,\n        expires_at: Optional[datetime] = None,\n    ) -> tuple[APIKey, str]:\n        \"\"\"Create a new API key.\"\"\"\n        # Generate a random key\n        import secrets\n        key = secrets.token_urlsafe(32)\n        key_hash = hashlib.sha256(key.encode()).hexdigest()\n        \n        api_key = APIKey(\n            id=uuid4(),\n            user_id=user_id,\n            name=name,\n            key_hash=key_hash,\n            scopes=scopes,\n            rate_limit_requests=rate_limit_requests,\n            rate_limit_window_seconds=rate_limit_window_seconds,\n            expires_at=expires_at,\n            is_active=True,\n        )\n        db.add(api_key)\n        await db.commit()\n        return api_key, key\n    \n    @staticmethod\n    async def get_api_key(db: AsyncSession, key_id: UUID) -> Optional[APIKey]:\n        \"\"\"Get an API key by ID.\"\"\"\n        result = await db.execute(\n            select(APIKey).where(APIKey.id == key_id)\n        )\n        return result.scalar_one_or_none()\n    \n    @staticmethod\n    async def verify_api_key(db: AsyncSession, key: str) -> Optional[APIKey]:\n        \"\"\"Verify an API key.\"\"\"\n        key_hash = hashlib.sha256(key.encode()).hexdigest()\n        result = await db.execute(\n            select(APIKey).where(\n                and_(\n                    APIKey.key_hash == key_hash,\n                    APIKey.is_active.is_(True),\n                )\n            )\n        )\n        api_key = result.scalar_one_or_none()\n        if api_key:\n            # Check expiration\n            if api_key.expires_at and api_key.expires_at < datetime.utcnow():\n                return None\n            # Update last_used\n            api_key.last_used = datetime.utcnow()\n            await db.commit()\n        return api_key\n    \n    @staticmethod\n    async def list_api_keys(\n        db: AsyncSession,\n        user_id: UUID,\n        skip: int = 0,\n        limit: int = 20,\n    ) -> List[APIKey]:\n        \"\"\"List API keys for a user.\"\"\"\n        result = await db.execute(\n            select(APIKey)\n            .where(APIKey.user_id == user_id)\n            .offset(skip)\n            .limit(limit)\n        )\n        return result.scalars().all()\n    \n    @staticmethod\n    async def revoke_api_key(db: AsyncSession, key_id: UUID) -> Optional[APIKey]:\n        \"\"\"Revoke an API key.\"\"\"\n        api_key = await APIGatewayService.get_api_key(db, key_id)\n        if api_key:\n            api_key.is_active = False\n            await db.commit()\n        return api_key\n    \n    @staticmethod\n    async def get_or_create_quota(\n        db: AsyncSession,\n        user_id: Optional[UUID] = None,\n        api_key_id: Optional[UUID] = None,\n    ) -> RateLimitQuota:\n        \"\"\"Get or create a rate limit quota.\"\"\"\n        result = await db.execute(\n            select(RateLimitQuota).where(\n                and_(\n                    RateLimitQuota.user_id == user_id,\n                    RateLimitQuota.api_key_id == api_key_id,\n                )\n            )\n        )\n        quota = result.scalar_one_or_none()\n        if not quota:\n            quota = RateLimitQuota(\n                id=uuid4(),\n                user_id=user_id,\n                api_key_id=api_key_id,\n            )\n            db.add(quota)\n            await db.commit()\n        return quota\n    \n    @staticmethod\n    async def check_rate_limit(\n        db: AsyncSession,\n        user_id: Optional[UUID] = None,\n        api_key_id: Optional[UUID] = None,\n    ) -> bool:\n        \"\"\"Check if a request is within rate limits.\"\"\"\n        quota = await APIGatewayService.get_or_create_quota(db, user_id, api_key_id)\n        now = datetime.utcnow()\n        \n        # Reset windows if needed\n        if quota.minute_window_start and (now - quota.minute_window_start).total_seconds() >= 60:\n            quota.requests_this_minute = 0\n            quota.minute_window_start = now\n        \n        if quota.hour_window_start and (now - quota.hour_window_start).total_seconds() >= 3600:\n            quota.requests_this_hour = 0\n            quota.hour_window_start = now\n        \n        if quota.day_window_start and (now - quota.day_window_start).total_seconds() >= 86400:\n            quota.requests_this_day = 0\n            quota.day_window_start = now\n        \n        # Check limits\n        if (quota.requests_this_minute >= quota.requests_per_minute or\n            quota.requests_this_hour >= quota.requests_per_hour or\n            quota.requests_this_day >= quota.requests_per_day):\n            quota.is_blocked = True\n            quota.blocked_until = now + timedelta(minutes=1)\n            await db.commit()\n            return False\n        \n        # Increment counters\n        quota.requests_this_minute += 1\n        quota.requests_this_hour += 1\n        quota.requests_this_day += 1\n        \n        if not quota.minute_window_start:\n            quota.minute_window_start = now\n        if not quota.hour_window_start:\n            quota.hour_window_start = now\n        if not quota.day_window_start:\n            quota.day_window_start = now\n        \n        await db.commit()\n        return True\n    \n    @staticmethod\n    async def record_analytics(\n        db: AsyncSession,\n        period_start: datetime,\n        period_end: datetime,\n        period_type: str,\n        total_requests: int,\n        successful_requests: int,\n        failed_requests: int,\n        avg_response_time_ms: float,\n        p50_response_time_ms: float,\n        p95_response_time_ms: float,\n        p99_response_time_ms: float,\n        error_rate: float,\n        top_errors: Dict[str, int],\n        requests_by_route: Dict[str, int],\n        requests_by_user: Dict[str, int],\n        total_request_bytes: int,\n        total_response_bytes: int,\n    ) -> APIAnalytics:\n        \"\"\"Record API analytics.\"\"\"\n        analytics = APIAnalytics(\n            id=uuid4(),\n            period_start=period_start,\n            period_end=period_end,\n            period_type=period_type,\n            total_requests=total_requests,\n            successful_requests=successful_requests,\n            failed_requests=failed_requests,\n            avg_response_time_ms=avg_response_time_ms,\n            p50_response_time_ms=p50_response_time_ms,\n            p95_response_time_ms=p95_response_time_ms,\n            p99_response_time_ms=p99_response_time_ms,\n            error_rate=error_rate,\n            top_errors=top_errors,\n            requests_by_route=requests_by_route,\n            requests_by_user=requests_by_user,\n            total_request_bytes=total_request_bytes,\n            total_response_bytes=total_response_bytes,\n        )\n        db.add(analytics)\n        await db.commit()\n        return analytics\n    \n    @staticmethod\n    async def create_graphql_schema(\n        db: AsyncSession,\n        name: str,\n        version: str,\n        schema_definition: str,\n        description: Optional[str] = None,\n    ) -> GraphQLSchema:\n        \"\"\"Create a GraphQL schema.\"\"\"\n        schema = GraphQLSchema(\n            id=uuid4(),\n            name=name,\n            version=version,\n            schema_definition=schema_definition,\n            description=description,\n            is_active=False,\n        )\n        db.add(schema)\n        await db.commit()\n        return schema\n    \n    @staticmethod\n    async def activate_graphql_schema(\n        db: AsyncSession,\n        schema_id: UUID,\n    ) -> Optional[GraphQLSchema]:\n        \"\"\"Activate a GraphQL schema.\"\"\"\n        result = await db.execute(\n            select(GraphQLSchema).where(GraphQLSchema.id == schema_id)\n        )\n        schema = result.scalar_one_or_none()\n        if schema:\n            schema.is_active = True\n            await db.commit()\n        return schema\n
