"""Collaboration router for real-time editing and session management."""

from typing import List, Optional
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession

from app.database import get_db
from app.models.user import User
from app.schemas.collaboration import (\n    CollaborativeSessionCreate,\n    CollaborativeSessionResponse,\n    CollaborativeSessionUpdate,\n    CollaborativeEditCreate,\n    CollaborativeEditResponse,\n    SessionCommentCreate,\n    SessionCommentResponse,\n    SessionHistoryResponse,\n    SessionParticipantResponse,\n    SessionPresenceUpdate,\n)\nfrom app.security.auth import get_current_user\nfrom app.services.collaboration import CollaborationService\n\nrouter = APIRouter(prefix=\"/collaboration\", tags=[\"collaboration\"])\n\n\n@router.post(\"/sessions\", response_model=CollaborativeSessionResponse, status_code=status.HTTP_201_CREATED)\nasync def create_session(\n    session_data: CollaborativeSessionCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Create a new collaborative session.\"\"\"\n    session = await CollaborationService.create_session(\n        db=db,\n        title=session_data.title,\n        description=session_data.description,\n        created_by=current_user.id,\n        circuit_id=session_data.circuit_id,\n        project_id=session_data.project_id,\n        max_participants=session_data.max_participants,\n    )\n    return session\n\n\n@router.get(\"/sessions/{session_id}\", response_model=CollaborativeSessionResponse)\nasync def get_session(\n    session_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get a collaborative session.\"\"\"\n    session = await CollaborationService.get_session(db, session_id)\n    if not session:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Session not found\")\n    return session\n\n\n@router.get(\"/sessions\", response_model=List[CollaborativeSessionResponse])\nasync def list_sessions(\n    skip: int = 0,\n    limit: int = 20,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List collaborative sessions for the current user.\"\"\"\n    sessions = await CollaborationService.list_sessions(db, current_user.id, skip, limit)\n    return sessions\n\n\n@router.put(\"/sessions/{session_id}\", response_model=CollaborativeSessionResponse)\nasync def update_session(\n    session_id: UUID,\n    session_data: CollaborativeSessionUpdate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update a collaborative session.\"\"\"\n    session = await CollaborationService.get_session(db, session_id)\n    if not session:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Session not found\")\n    \n    # Check authorization\n    if session.created_by != current_user.id:\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=\"Not authorized\")\n    \n    # Update fields\n    update_data = session_data.model_dump(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(session, field, value)\n    \n    await db.commit()\n    return session\n\n\n@router.post(\"/sessions/{session_id}/participants\", response_model=SessionParticipantResponse, status_code=status.HTTP_201_CREATED)\nasync def add_participant(\n    session_id: UUID,\n    user_id: UUID,\n    can_edit: bool = True,\n    can_delete: bool = False,\n    can_invite: bool = False,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Add a participant to a session.\"\"\"\n    session = await CollaborationService.get_session(db, session_id)\n    if not session:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Session not found\")\n    \n    participant = await CollaborationService.add_participant(\n        db, session_id, user_id, can_edit, can_delete, can_invite\n    )\n    return participant\n\n\n@router.delete(\"/sessions/{session_id}/participants/{user_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def remove_participant(\n    session_id: UUID,\n    user_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Remove a participant from a session.\"\"\"\n    session = await CollaborationService.get_session(db, session_id)\n    if not session:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Session not found\")\n    \n    success = await CollaborationService.remove_participant(db, session_id, user_id)\n    if not success:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Participant not found\")\n\n\n@router.post(\"/sessions/{session_id}/presence\", response_model=SessionParticipantResponse)\nasync def update_presence(\n    session_id: UUID,\n    presence_data: SessionPresenceUpdate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Update user presence in a session.\"\"\"\n    participant = await CollaborationService.update_presence(\n        db,\n        session_id,\n        current_user.id,\n        presence_data.is_online,\n        presence_data.cursor_position,\n        presence_data.selected_text,\n    )\n    if not participant:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Participant not found\")\n    return participant\n\n\n@router.post(\"/sessions/{session_id}/edits\", response_model=CollaborativeEditResponse, status_code=status.HTTP_201_CREATED)\nasync def record_edit(\n    session_id: UUID,\n    edit_data: CollaborativeEditCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Record a collaborative edit.\"\"\"\n    session = await CollaborationService.get_session(db, session_id)\n    if not session:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Session not found\")\n    \n    edit = await CollaborationService.record_edit(\n        db,\n        session_id,\n        current_user.id,\n        edit_data.operation,\n        edit_data.path,\n        edit_data.value,\n        edit_data.old_value,\n    )\n    return edit\n\n\n@router.get(\"/sessions/{session_id}/history\", response_model=SessionHistoryResponse)\nasync def get_history(\n    session_id: UUID,\n    skip: int = 0,\n    limit: int = 100,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get edit history for a session.\"\"\"\n    session = await CollaborationService.get_session(db, session_id)\n    if not session:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Session not found\")\n    \n    edits = await CollaborationService.get_edit_history(db, session_id, skip, limit)\n    conflicts_resolved = sum(1 for edit in edits if edit.conflict_resolved)\n    last_edit_time = edits[0].timestamp if edits else None\n    \n    return SessionHistoryResponse(\n        total_edits=len(edits),\n        edits=edits,\n        conflicts_resolved=conflicts_resolved,\n        last_edit_time=last_edit_time,\n    )\n\n\n@router.post(\"/sessions/{session_id}/comments\", response_model=SessionCommentResponse, status_code=status.HTTP_201_CREATED)\nasync def add_comment(\n    session_id: UUID,\n    comment_data: SessionCommentCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Add a comment to a session.\"\"\"\n    session = await CollaborationService.get_session(db, session_id)\n    if not session:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Session not found\")\n    \n    comment = await CollaborationService.add_comment(\n        db,\n        session_id,\n        current_user.id,\n        comment_data.content,\n        comment_data.code_reference,\n        comment_data.line_number,\n        comment_data.parent_comment_id,\n    )\n    return comment\n\n\n@router.get(\"/sessions/{session_id}/comments\", response_model=List[SessionCommentResponse])\nasync def get_comments(\n    session_id: UUID,\n    skip: int = 0,\n    limit: int = 50,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get comments for a session.\"\"\"\n    session = await CollaborationService.get_session(db, session_id)\n    if not session:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Session not found\")\n    \n    comments = await CollaborationService.get_comments(db, session_id, skip, limit)\n    return comments\n\n\n@router.post(\"/comments/{comment_id}/resolve\", response_model=SessionCommentResponse)\nasync def resolve_comment(\n    comment_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Mark a comment as resolved.\"\"\"\n    comment = await CollaborationService.resolve_comment(db, comment_id)\n    if not comment:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Comment not found\")\n    return comment\n\n\n@router.get(\"/sessions/{session_id}/stats\")\nasync def get_session_stats(\n    session_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get statistics for a collaborative session.\"\"\"\n    stats = await CollaborationService.get_session_stats(db, session_id)\n    if not stats:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Session not found\")\n    return stats\n
