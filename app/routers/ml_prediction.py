"""ML Prediction router for Phase 6 intelligence features.\"\"\"\n\nfrom typing import List, Optional\nfrom uuid import UUID\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom app.database import get_db\nfrom app.models.user import User\nfrom app.schemas.ml_prediction import (\n    MLModelCreate,\n    MLModelResponse,\n    MLModelUpdate,\n    MLPredictionCreate,\n    MLPredictionResponse,\n    CircuitOptimizationCreate,\n    CircuitOptimizationResponse,\n    ResourceEstimateCreate,\n    ResourceEstimateResponse,\n    PatternAnalysisCreate,\n    PatternAnalysisResponse,\n    PredictionFeedback,\n    OptimizationApply,\n)\nfrom app.security.auth import get_current_user\nfrom app.services.ml_prediction import MLPredictionService\n\nrouter = APIRouter(prefix=\"/ml\", tags=[\"ml-prediction\"])\n\n\n@router.post(\"/models\", response_model=MLModelResponse, status_code=status.HTTP_201_CREATED)\nasync def create_model(\n    model_data: MLModelCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Create a new ML model.\"\"\"\n    model = await MLPredictionService.create_model(\n        db=db,\n        name=model_data.name,\n        version=model_data.version,\n        model_type=model_data.model_type,\n        framework=model_data.framework,\n        input_schema=model_data.input_schema,\n        output_schema=model_data.output_schema,\n        description=model_data.description,\n    )\n    return model\n\n\n@router.get(\"/models/{model_id}\", response_model=MLModelResponse)\nasync def get_model(\n    model_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get an ML model.\"\"\"\n    model = await MLPredictionService.get_model(db, model_id)\n    if not model:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Model not found\")\n    return model\n\n\n@router.get(\"/models\", response_model=List[MLModelResponse])\nasync def list_models(\n    model_type: Optional[str] = None,\n    is_active: Optional[bool] = None,\n    is_production: Optional[bool] = None,\n    skip: int = 0,\n    limit: int = 20,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"List ML models.\"\"\"\n    models = await MLPredictionService.list_models(\n        db, model_type, is_active, is_production, skip, limit\n    )\n    return models\n\n\n@router.post(\"/models/{model_id}/activate\", response_model=MLModelResponse)\nasync def activate_model(\n    model_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Activate an ML model.\"\"\"\n    model = await MLPredictionService.activate_model(db, model_id)\n    if not model:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Model not found\")\n    return model\n\n\n@router.post(\"/models/{model_id}/promote\", response_model=MLModelResponse)\nasync def promote_model(\n    model_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Promote an ML model to production.\"\"\"\n    model = await MLPredictionService.promote_to_production(db, model_id)\n    if not model:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Model not found\")\n    return model\n\n\n@router.post(\"/predictions\", response_model=MLPredictionResponse, status_code=status.HTTP_201_CREATED)\nasync def create_prediction(\n    prediction_data: MLPredictionCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Record a machine learning prediction.\"\"\"\n    prediction = await MLPredictionService.record_prediction(\n        db=db,\n        user_id=current_user.id,\n        model_id=prediction_data.model_id,\n        prediction_type=prediction_data.prediction_type,\n        input_data=prediction_data.input_data,\n        predicted_output=prediction_data.predicted_output,\n        confidence=prediction_data.confidence,\n        circuit_id=prediction_data.circuit_id,\n        job_id=prediction_data.job_id,\n    )\n    return prediction\n\n\n@router.get(\"/predictions/{prediction_id}\", response_model=MLPredictionResponse)\nasync def get_prediction(\n    prediction_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get a prediction.\"\"\"\n    prediction = await MLPredictionService.get_prediction(db, prediction_id)\n    if not prediction:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Prediction not found\")\n    return prediction\n\n\n@router.get(\"/circuits/{circuit_id}/predictions\", response_model=List[MLPredictionResponse])\nasync def get_circuit_predictions(\n    circuit_id: UUID,\n    skip: int = 0,\n    limit: int = 20,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get predictions for a circuit.\"\"\"\n    predictions = await MLPredictionService.get_circuit_predictions(\n        db, circuit_id, skip, limit\n    )\n    return predictions\n\n\n@router.post(\"/predictions/{prediction_id}/feedback\")\nasync def add_feedback(\n    prediction_id: UUID,\n    feedback_data: PredictionFeedback,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Add feedback to a prediction.\"\"\"\n    prediction = await MLPredictionService.add_prediction_feedback(\n        db,\n        prediction_id,\n        feedback_data.rating,\n        feedback_data.feedback,\n        feedback_data.was_helpful,\n    )\n    if not prediction:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Prediction not found\")\n    return prediction\n\n\n@router.post(\"/optimizations\", response_model=CircuitOptimizationResponse, status_code=status.HTTP_201_CREATED)\nasync def create_optimization(\n    optimization_data: CircuitOptimizationCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Record a circuit optimization.\"\"\"\n    optimization = await MLPredictionService.record_optimization(\n        db=db,\n        prediction_id=optimization_data.prediction_id,\n        circuit_id=optimization_data.circuit_id,\n        original_gate_count=optimization_data.original_gate_count,\n        original_depth=optimization_data.original_depth,\n        original_two_qubit_gates=optimization_data.original_two_qubit_gates,\n        optimized_gate_count=optimization_data.optimized_gate_count,\n        optimized_depth=optimization_data.optimized_depth,\n        optimized_two_qubit_gates=optimization_data.optimized_two_qubit_gates,\n        optimization_technique=optimization_data.optimization_technique,\n        optimization_steps=optimization_data.optimization_steps,\n        optimized_circuit=optimization_data.optimized_circuit,\n    )\n    return optimization\n\n\n@router.post(\"/optimizations/{optimization_id}/apply\")\nasync def apply_optimization(\n    optimization_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Apply an optimization.\"\"\"\n    optimization = await MLPredictionService.apply_optimization(db, optimization_id)\n    if not optimization:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Optimization not found\")\n    return optimization\n\n\n@router.post(\"/estimates\", response_model=ResourceEstimateResponse, status_code=status.HTTP_201_CREATED)\nasync def create_estimate(\n    estimate_data: ResourceEstimateCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Record a resource estimate.\"\"\"\n    estimate = await MLPredictionService.record_resource_estimate(\n        db=db,\n        prediction_id=estimate_data.prediction_id,\n        circuit_id=estimate_data.circuit_id,\n        qubits_required=estimate_data.qubits_required,\n        classical_bits_required=estimate_data.classical_bits_required,\n        single_qubit_gates=estimate_data.single_qubit_gates,\n        two_qubit_gates=estimate_data.two_qubit_gates,\n        measurement_gates=estimate_data.measurement_gates,\n        circuit_depth=estimate_data.circuit_depth,\n        circuit_width=estimate_data.circuit_width,\n        estimated_execution_time_ms=estimate_data.estimated_execution_time_ms,\n        compatible_backends=estimate_data.compatible_backends,\n        confidence=estimate_data.confidence,\n        recommended_backend=estimate_data.recommended_backend,\n    )\n    return estimate\n\n\n@router.post(\"/patterns\", response_model=PatternAnalysisResponse, status_code=status.HTTP_201_CREATED)\nasync def create_pattern_analysis(\n    analysis_data: PatternAnalysisCreate,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Record a pattern analysis.\"\"\"\n    analysis = await MLPredictionService.record_pattern_analysis(\n        db=db,\n        prediction_id=analysis_data.prediction_id,\n        circuit_id=analysis_data.circuit_id,\n        detected_patterns=analysis_data.detected_patterns,\n        pattern_confidence=analysis_data.pattern_confidence,\n        recommended_optimizations=analysis_data.recommended_optimizations,\n        algorithm_type=analysis_data.algorithm_type,\n        algorithm_confidence=analysis_data.algorithm_confidence,\n        alternative_implementations=analysis_data.alternative_implementations,\n        similar_circuits=analysis_data.similar_circuits,\n        similarity_scores=analysis_data.similarity_scores,\n    )\n    return analysis\n\n\n@router.get(\"/models/{model_id}/performance\")\nasync def get_model_performance(\n    model_id: UUID,\n    current_user: User = Depends(get_current_user),\n    db: AsyncSession = Depends(get_db),\n):\n    \"\"\"Get performance metrics for a model.\"\"\"\n    performance = await MLPredictionService.get_model_performance(db, model_id)\n    if not performance:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Model not found\")\n    return performance\n
